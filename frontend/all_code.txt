=== FILE START: ./vue.config.js ===
// vue.config.js
module.exports = {
    // 部署应用包时的基本 URL
    // 假设你要将项目部署在 mer.dev/arknights-wordle 下
    // 则这里应设置为 '/arknights-wordle/'
    publicPath: '/arknights-wordle/'
  }
  
=== FILE END: ./vue.config.js ===

=== FILE START: ./.eslintrc.js ===
module.exports = {
    root: true,
    env: {
        node: true
    },
    extends: [
        'plugin:vue/vue3-essential',
        'eslint:recommended'
    ],
    parserOptions: {
        parser: '@babel/eslint-parser',
        requireConfigFile: false // 这一行是关键，告诉ESLint不需要Babel配置文件
    },
    rules: {
        'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
        'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
        'no-unused-vars': 'warn', // 警告未使用的变量
    }
};
=== FILE END: ./.eslintrc.js ===

=== FILE START: ./src/App.vue ===
<template>
  <div class="app-wrapper">
    <!-- 顶部Header -->
    <header class="app-header">
      <h1>猜！干！员！</h1>
      <button class="theme-toggle" @click="toggleTheme">{{ themeText }}</button>
      <div class="rules-explanation">
        <p>
          <strong>数据 & 图片来源：prts.wiki</strong><br />
          <strong>玩法说明:</strong><br />
          如果数值不完全匹配，将会显示一枚箭头：<br />
          <span class="arrow-symbol up-arrow">↑</span> 表示应该猜得更大一点<br />
          <span class="arrow-symbol down-arrow">↓</span> 表示应该猜得更小一点<br />
          橙色底代表与目标差距较小，而红色底代表差距较大。<br />
          搜索框拼音仅支持全拼，需要打空格。<br />
          立绘像素化的代码非常小杯，但也是一种乐趣...可能存在颜色不准的情况。<br />
        </p>
      </div>
    </header>

    <!-- 主容器：左侧游戏区域 + 右侧预留 scoreboard 容器 -->
    <div class="main-layout">
      <main class="app-main">
        <div v-if="loading" class="loading">
          <p>加载中...</p>
        </div>
        <div v-else>
          <!-- 搜索框 -->
          <guess-input
            :operators="filteredOperators"
            :disabled="gameOver || gameWon"
            @submit="makeGuess"
            class="top-search"
          />

          <!-- 难度标签选择 -->
          <tag-selector
            :tagGroups="tagGroups"
            :selectedGroup="selectedTagGroup"
            @select="selectTagGroup"
            class="tag-selector-container"
          />

          <!-- puzzle 模式高级设置(只猜六星, 调整最大次数, 放弃) -->
          <div v-if="selectedTagGroup.id === 'puzzle'">
            <div class="advanced-settings">
              <button class="toggle-button" @click="showAdvanced = !showAdvanced">
                {{ showAdvanced ? '收起▲' : '高级设置▼' }}
              </button>
              <transition name="fade">
                <div v-if="showAdvanced" class="advanced-content">
                  <div class="switch-row">
                    <div class="switch-container">
                      <span class="switch-label">只猜六星:</span>
                      <label class="switch">
                        <input type="checkbox" v-model="onlySixStar" />
                        <span class="slider round"></span>
                      </label>
                      <span class="switch-value">{{ onlySixStar ? '是' : '否' }}</span>
                    </div>
                  </div>

                  <div class="slider-container">
                    <label class="slider-label">最大猜测次数: {{ maxGuesses }}</label>
                    <input type="range" min="3" max="15" v-model.number="maxGuesses" class="slider-input" />
                  </div>
                  <div class="give-up-container">
                    <button class="give-up-button" @click="giveUpGame" :disabled="gameOver || gameWon">
                      放弃游戏
                    </button>
                  </div>
                </div>
              </transition>
            </div>
          </div>

          <!-- 普通模式高级设置 -->
          <div v-else>
            <div class="advanced-settings">
              <button class="toggle-button" @click="showAdvanced = !showAdvanced">
                {{ showAdvanced ? '收起▲' : '高级设置▼' }}
              </button>

              <transition name="fade">
                <div v-if="showAdvanced" class="advanced-content">
                  <div class="switch-row">
                    <div class="switch-container">
                      <span class="switch-label">只猜六星:</span>
                      <label class="switch">
                        <input type="checkbox" v-model="onlySixStar" />
                        <span class="slider round"></span>
                      </label>
                      <span class="switch-value">{{ onlySixStar ? '是' : '否' }}</span>
                    </div>

                    <div v-if="selectedTagGroup.id !== 'easy'" class="switch-container">
                      <span class="switch-label">潜能:</span>
                      <label class="switch">
                        <input type="checkbox" v-model="potentialMode" :true-value="'满潜'" :false-value="'0潜'" />
                        <span class="slider round"></span>
                      </label>
                      <span class="switch-value">{{ potentialMode }}</span>
                    </div>

                    <div v-if="selectedTagGroup.id !== 'easy'" class="switch-container">
                      <span class="switch-label">信赖:</span>
                      <label class="switch">
                        <input type="checkbox" v-model="trustMode" :true-value="'满信赖'" :false-value="'0信赖'" />
                        <span class="slider round"></span>
                      </label>
                      <span class="switch-value">{{ trustMode }}</span>
                    </div>
                  </div>

                  <div class="slider-container">
                    <label class="slider-label">最大猜测次数: {{ maxGuesses }}</label>
                    <input
                      type="range"
                      :max="selectedTagGroup.id === 'hard' ? 12 : 12"
                      :min="3"
                      v-model.number="maxGuesses"
                      class="slider-input"
                    />
                  </div>

                  <div class="give-up-container">
                    <button class="give-up-button" @click="giveUpGame" :disabled="gameOver || gameWon">
                      放弃游戏
                    </button>
                  </div>
                </div>
              </transition>
            </div>
          </div>

          <!-- 游戏区：根据模式切换 -->
          <game-board
            v-if="selectedTagGroup.id !== 'puzzle'"
            :operatorData="filteredOperators"
            :guesses="guesses"
            :comparisons="comparisons"
            :targetOperator="targetOperator"
            :gameOver="gameOver"
            :gameWon="gameWon"
            :maxGuesses="maxGuesses"
            :userGaveUp="userGaveUp"
            :potentialMode="potentialMode"
            :trustMode="trustMode"
            :selectedTagGroup="selectedTagGroup"
            @reset="resetGame"
          />

          <puzzle-board
            v-else
            :operators="filteredOperators"
            :targetOperator="targetOperator"
            :maxGuesses="maxGuesses"
            :gameOver="gameOver"
            :gameWon="gameWon"
            :userGaveUp="userGaveUp"
            :guesses="guesses"
            @reset="resetGame"
          />
        </div>
      </main>

      <!-- 未来多人模式/记分板容器(现在先占位) -->
      <!-- <aside class="scoreboard-container"> -->
        <!-- 在多人模式/双人竞赛时，这里可以放玩家分数等 -->
        <!-- 目前留空，用于布局测试 -->
      <!-- </aside> -->
    </div>

    <footer class="app-footer">
      <p>© 2025 AndyBlocker</p>
    </footer>
  </div>
</template>

<script>
import { ref, onMounted, watch, computed } from 'vue';

import GameBoard from './components/GameBoard.vue';
import GuessInput from './components/GuessInput.vue';
import TagSelector from './components/TagSelector.vue';
import PuzzleBoard from './components/PuzzleBoard.vue';

import { loadOperatorsData } from './utils/dataLoader';
import {
  preprocessOperators,
  filterByOnlySixStar,
  selectRandomOperator,
  compareOperators
} from './logic/gameLogic';

import { saveSettings, loadSettings } from './utils/cookieSettings';
import { getCurrentTheme, setTheme } from './themes';

export default {
  name: 'App',
  components: {
    GameBoard,
    GuessInput,
    TagSelector,
    PuzzleBoard
  },
  setup() {
    const loading = ref(true);
    const operatorData = ref([]);

    const maxGuesses = ref(6);
    const guesses = ref([]);
    const comparisons = ref([]);
    const targetOperator = ref(null);
    const gameOver = ref(false);
    const gameWon = ref(false);
    const potentialMode = ref('满潜');
    const trustMode = ref('满信赖');
    const userGaveUp = ref(false);
    const onlySixStar = ref(false);

    const tagGroups = ref([
      {
        id: 'hard',
        name: '兔头',
        // 在此处新增“上线年份”
        tags: ['星级', '满级攻击', '满级生命', '满级防御', '满级法术抗性', '攻击间隔', '上线年份', '标签']
      },
      {
        id: 'easy',
        name: '大头',
        tags: ['性别', '星级', '职业', '国家', '种族', '源石技艺适应性', '身高', '感染状态', '出生日期', '标签']
      },
      {
        id: 'puzzle',
        name: '小头...?',
        description: '通过像素化立绘逐步细化来猜干员',
        tags: []
      }
    ]);
    const selectedTagGroup = ref(tagGroups.value[0]);
    const showAdvanced = ref(false);

    // 主题
    const currentTheme = ref(getCurrentTheme());
    const themeText = computed(() => (currentTheme.value === 'dark' ? '浅色模式' : '深色模式'));

    const filteredOperators = computed(() => {
      if (onlySixStar.value) {
        return filterByOnlySixStar(operatorData.value);
      }
      return operatorData.value;
    });

    const selectTagGroup = (groupId) => {
      const group = tagGroups.value.find((g) => g.id === groupId);
      if (group) {
        selectedTagGroup.value = group;
        resetGame();
      }
    };

    // 初始化 & 加载数据
    onMounted(async () => {
      initFromCookies();
      await loadData();
    });

    const initFromCookies = () => {
      const settings = loadSettings();
      if (settings) {
        if (typeof settings.onlySixStar === 'boolean') {
          onlySixStar.value = settings.onlySixStar;
        }
        if (typeof settings.maxGuesses === 'number') {
          maxGuesses.value = settings.maxGuesses;
        }
        if (settings.selectedTagGroupId) {
          const group = tagGroups.value.find((g) => g.id === settings.selectedTagGroupId);
          if (group) selectedTagGroup.value = group;
        }
        if (settings.potentialMode) {
          potentialMode.value = settings.potentialMode;
        }
        if (settings.trustMode) {
          trustMode.value = settings.trustMode;
        }
      }
      // 应用主题
      setTheme(currentTheme.value);
    };

    watch(
      [
        onlySixStar,
        maxGuesses,
        selectedTagGroup,
        potentialMode,
        trustMode,
        currentTheme
      ],
      () => {
        saveToCookies();
      },
      { deep: true }
    );

    const saveToCookies = () => {
      const settings = {
        onlySixStar: onlySixStar.value,
        maxGuesses: maxGuesses.value,
        selectedTagGroupId: selectedTagGroup.value.id,
        potentialMode: potentialMode.value,
        trustMode: trustMode.value
      };
      saveSettings(settings);
      // 主题
      setTheme(currentTheme.value);
    };

    // 监听 onlySixStar 改变，自动重新开局
    watch(onlySixStar, () => {
      resetGame();
    });

    // 加载干员数据
    const loadData = async () => {
      try {
        const data = await loadOperatorsData('./data/operators.json');
        preprocessOperators(data);
        operatorData.value = data;
      } catch (err) {
        console.error('加载干员数据失败:', err);
      } finally {
        loading.value = false;
        pickRandomTarget();
      }
    };

    const pickRandomTarget = () => {
      targetOperator.value = selectRandomOperator(filteredOperators.value);
      if (targetOperator.value) {
        console.log('目标干员已设定:', targetOperator.value.干员);
      } else {
        console.warn('没有符合条件的干员（可能只猜六星，但数据中没有六星）');
      }
    };

    const makeGuess = (operatorName) => {
      const guessedOp = filteredOperators.value.find((op) => op.干员 === operatorName);
      if (!guessedOp) {
        console.error('未找到干员:', operatorName);
        return;
      }

      // puzzle模式
      if (selectedTagGroup.value.id === 'puzzle') {
        guesses.value.push(guessedOp);
        if (guessedOp.干员 === targetOperator.value?.干员) {
          gameWon.value = true;
        }
        if (guesses.value.length >= maxGuesses.value && !gameWon.value) {
          gameOver.value = true;
        }
      } else {
        // 普通模式
        guesses.value.push(guessedOp);
        comparisons.value.push(
          compareOperators(
            guessedOp,
            targetOperator.value,
            selectedTagGroup.value.tags,
            potentialMode.value,
            trustMode.value
          )
        );

        if (guessedOp.干员 === targetOperator.value?.干员) {
          gameWon.value = true;
        }
        if (guesses.value.length >= maxGuesses.value && !gameWon.value) {
          gameOver.value = true;
        }
      }
    };

    const giveUpGame = () => {
      userGaveUp.value = true;
      gameOver.value = true;
    };

    const resetGame = () => {
      guesses.value = [];
      comparisons.value = [];
      gameOver.value = false;
      gameWon.value = false;
      userGaveUp.value = false;
      pickRandomTarget();
    };

    // 当潜能或信赖或 maxGuesses 改变，需要重新计算对比结果
    watch([potentialMode, trustMode, maxGuesses], () => {
      if (selectedTagGroup.value.id !== 'puzzle' && guesses.value.length > 0) {
        recalcAllComparisons();
      }
    });

    const recalcAllComparisons = () => {
      comparisons.value = guesses.value.map((guess) =>
        compareOperators(guess, targetOperator.value, selectedTagGroup.value.tags, potentialMode.value, trustMode.value)
      );
      if (guesses.value.length >= maxGuesses.value && !gameWon.value) {
        gameOver.value = true;
      }
    };

    const toggleTheme = () => {
      currentTheme.value = currentTheme.value === 'light' ? 'dark' : 'light';
    };

    return {
      loading,
      operatorData,
      maxGuesses,
      guesses,
      comparisons,
      targetOperator,
      gameOver,
      gameWon,
      potentialMode,
      trustMode,
      userGaveUp,
      onlySixStar,

      tagGroups,
      selectedTagGroup,
      showAdvanced,

      filteredOperators,
      selectTagGroup,
      makeGuess,
      resetGame,
      giveUpGame,

      currentTheme,
      themeText,
      toggleTheme
    };
  }
};
</script>

<style>
/* 
  这里去掉 scoped，让全局生效，以便使用 :root 和[data-theme="xx"]的变量 
  同时也能让深色模式等全局样式生效 
*/

.app-wrapper {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  background-color: var(--color-bg);
  color: var(--color-text);
  transition: background-color var(--transition-duration), color var(--transition-duration);
}

.app-header {
  text-align: center;
  padding: 20px;
  background-color: var(--color-header-bg);
  color: var(--color-header-text);
  border-radius: 0 0 12px 12px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  position: relative;
}

/* 主题切换按钮 */
.theme-toggle {
  position: absolute;
  top: 20px;
  right: 20px;
  background-color: var(--color-primary);
  color: #fff;
  border: none;
  padding: 6px 12px;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color var(--transition-duration);
}
.theme-toggle:hover {
  background-color: var(--color-primary-hover);
}

.rules-explanation {
  margin: 10px auto 0 auto;
  max-width: 700px;
  background-color: rgba(255, 255, 255, 0.1);
  backdrop-filter: saturate(150%) blur(5px);
  padding: 12px 16px;
  border-radius: 6px;
  font-size: 14px;
  line-height: 1.4;
  text-align: left;
}

/* 主布局：左内容 + 右边 scoreboard  */
.main-layout {
  display: flex;
  flex: 1;
  max-width: 1700px;
  width: 100%;
  margin: 20px auto;
  gap: 16px;
  padding: 0 16px;
}

.app-main {
  flex: 1;
  background-color: var(--color-card-bg);
  border-radius: 12px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.05);
  padding: 20px;
  min-height: 600px; /* 给点空间 */
  transition: background-color var(--transition-duration);
}

.scoreboard-container {
  width: 300px;
  border-radius: 12px;
  background-color: var(--color-card-bg);
  box-shadow: 0 2px 10px rgba(0,0,0,0.05);
  padding: 20px;
  display: none; /* 默认隐藏，等多人模式开放再显示 */
  transition: background-color var(--transition-duration);
}

@media (min-width: 1400px) {
  .scoreboard-container {
    display: block; /* 宽屏下可以展示，也可自行决定 */
  }
}

.loading {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 300px;
  font-size: 18px;
  color: #666;
}

/* 顶部搜索框 */
.top-search {
  margin-bottom: 20px;
}

.tag-selector-container {
  margin-bottom: 20px;
}

/* 箭头 */
.arrow-symbol {
  display: inline-block;
  font-weight: bold;
  margin: 0 4px;
}
.up-arrow {
  color: var(--color-correct);
}
.down-arrow {
  color: var(--color-far);
}

/* 高级设置半透明卡片 */
.advanced-settings {
  margin-bottom: 20px;
  text-align: center;
}

.toggle-button {
  background-color: var(--color-primary);
  color: #fff;
  border: none;
  padding: 8px 14px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  margin-bottom: 8px;
  transition: background-color var(--transition-duration);
}
.toggle-button:hover {
  background-color: var(--color-primary-hover);
}

.fade-enter-active,
.fade-leave-active {
  transition: opacity var(--transition-duration);
}
.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
.advanced-content {
  background-color: rgba(255, 255, 255, 0.12);
  backdrop-filter: blur(8px) brightness(1.15);
  border-radius: 8px;
  padding: 16px;
  margin: 0 auto;
  text-align: left;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  max-width: 600px;
}

.switch-row {
  display: flex;
  justify-content: space-evenly;
  margin-bottom: 16px;
  flex-wrap: wrap;
}
.switch-container {
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 8px 0;
}
.switch-label {
  min-width: 80px;
  text-align: right;
  color: var(--color-text);
  font-weight: 500;
}
.switch {
  position: relative;
  display: inline-block;
  width: 46px;
  height: 24px;
}
.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}
.slider {
  position: absolute;
  cursor: pointer;
  top: 0; left: 0; right: 0; bottom: 0;
  background-color: #aaa;
  transition: .4s;
  border-radius: 24px;
}
.slider:before {
  position: absolute;
  content: "";
  height: 18px; width: 18px;
  left: 3px; bottom: 3px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
}
input:checked + .slider {
  background-color: var(--color-primary);
}
input:checked + .slider:before {
  transform: translateX(22px);
}
.slider.round {
  border-radius: 24px;
}
.slider.round:before {
  border-radius: 50%;
}
.switch-value {
  min-width: 40px;
  text-align: left;
  color: var(--color-text);
}

.slider-container {
  margin-bottom: 16px;
  text-align: center;
}
.slider-label {
  display: inline-block;
  margin-right: 10px;
  font-weight: 500;
}
.slider-input {
  vertical-align: middle;
  cursor: pointer;
}

.give-up-container {
  text-align: center;
  margin-top: 10px;
}
.give-up-button {
  background-color: var(--color-far);
  color: #fff;
  border: none;
  padding: 8px 14px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color var(--transition-duration);
}
.give-up-button:hover {
  background-color: #b61827; /* 略微深一点的红 */
}

/* 页脚 */
.app-footer {
  text-align: center;
  padding: 20px 0;
  margin-top: 20px;
  color: #666;
  font-size: 14px;
}
</style>

=== FILE END: ./src/App.vue ===

=== FILE START: ./src/themes.js ===
import Cookies from 'js-cookie';

const THEME_COOKIE_KEY = 'arknightsWordle.theme';

/**
 * 获取当前主题（默认为 'light'）
 */
export function getCurrentTheme() {
  return Cookies.get(THEME_COOKIE_KEY) || 'light';
}

/**
 * 设置并应用主题到文档根节点
 */
export function setTheme(themeName) {
  Cookies.set(THEME_COOKIE_KEY, themeName, { expires: 365 });
  document.documentElement.setAttribute('data-theme', themeName);
}

/**
 * 初始化主题设置
 * 可在 main.js 或 App.vue 中 onMounted 时调用
 */
export function initTheme() {
  const theme = getCurrentTheme();
  document.documentElement.setAttribute('data-theme', theme);
}

=== FILE END: ./src/themes.js ===

=== FILE START: ./src/logic/parseUtils.js ===
// src/logic/parseUtils.js
export function parseBirthdayRaw(birthdayStr) {
    if (typeof birthdayStr !== 'string') return { month: null, day: null };
    const match = birthdayStr.match(/(\d+)月(\d+)日/);
    if (match) {
      return {
        month: parseInt(match[1], 10),
        day: parseInt(match[2], 10)
      };
    }
    return { month: null, day: null };
}

=== FILE END: ./src/logic/parseUtils.js ===

=== FILE START: ./src/logic/gameLogic.js ===
// src/logic/gameLogic.js
import { parseBirthday as parseBirthdayRaw } from './parseUtils.js'; 

export function parseBirthday(birthdayStr) {
  return parseBirthdayRaw(birthdayStr);
}

/**
 * 预处理数据
 */
export function preprocessOperators(data) {
  data.forEach(op => {
    // 稀有度 => 星级
    if (op.稀有度 !== undefined) {
      const rarityNum = parseInt(op.稀有度, 10) || 0;
      op.星级 = rarityNum + 1;
    }
    // 攻击速度 => 攻击间隔
    if (op.攻击速度) {
      const match = op.攻击速度.match(/([\d.]+)/);
      const interval = match ? parseFloat(match[1]) : 0;
      op.攻击间隔 = interval;
      delete op.攻击速度;
    }
    // 身高
    if (op.身高) {
      const heightNum = parseFloat(op.身高.replace('cm', '')) || 0;
      op.身高 = heightNum;
    }

    // 解析潜能加成
    op.__parsedPotential = {};
    if (op.潜能加成 && op.潜能加成.includes('`')) {
      const [keysStr, valsStr] = op.潜能加成.split('`');
      const keyList = keysStr.split(',').map(s => s.trim());
      const valList = valsStr.split(',').map(s => s.trim());
      const potentialMap = {
        atk: '满级攻击',
        hp: '满级生命',
        def: '满级防御',
        res: '满级法术抗性'
      };
      keyList.forEach((k, idx) => {
        const v = parseFloat(valList[idx]) || 0;
        const mappedField = potentialMap[k];
        if (mappedField) {
          op.__parsedPotential[mappedField] = v;
        }
      });
    }

    // 解析信赖加成
    op.__parsedTrust = {};
    if (op.信赖加成) {
      const trustVals = op.信赖加成.split(',').map(s => parseFloat(s.trim()) || 0);
      // [满级生命, 满级攻击, 满级防御]
      op.__parsedTrust['满级生命'] = trustVals[0] || 0;
      op.__parsedTrust['满级攻击'] = trustVals[1] || 0;
      op.__parsedTrust['满级防御'] = trustVals[2] || 0;
    }

    // 解析上线年份，只取年份
    if (op.上线时间) {
      const dateObj = new Date(op.上线时间);
      if (!isNaN(dateObj)) {
        op.上线年份 = dateObj.getFullYear();
      }
    }
  });
}

/**
 * 从一批干员中随机选择1位
 */
export function selectRandomOperator(operators) {
  if (!operators || !operators.length) return null;
  const idx = Math.floor(Math.random() * operators.length);
  return operators[idx];
}

/**
 * 根据 onlySixStar 筛选
 */
export function filterByOnlySixStar(operators) {
  return operators.filter(op => op.星级 === 6);
}

/**
 * 获取干员数值在潜能/信赖影响下的有效值
 */
export function getEffectiveValue(op, tag, potentialMode, trustMode) {
  const baseVal = parseFloat(op[tag]) || 0;
  let total = baseVal;
  // 满潜
  if (potentialMode === '满潜') {
    total += op.__parsedPotential?.[tag] || 0;
  }
  // 满信赖
  if (trustMode === '满信赖') {
    total += op.__parsedTrust?.[tag] || 0;
  }
  return total;
}

/**
 * 对比 guessed 和 target 干员在指定 tags 下的数据
 */
export function compareOperators(guessed, target, tags, potentialMode, trustMode) {
  const comparison = {};
  if (!target) return comparison;

  tags.forEach(tag => {
    if (tag === '标签') {
      const guessTags = guessed[tag]?.split(' ').map(s => s.trim()).filter(Boolean) || [];
      const targetTags = target[tag]?.split(' ').map(s => s.trim()).filter(Boolean) || [];
      const correctTags = guessTags.filter(g => targetTags.includes(g));
      comparison[tag] = { guessTags, targetTags, correctTags };
    }
    else if (tag === '出生日期') {
      comparison[tag] = compareBirthdays(guessed[tag], target[tag]);
    }
    else if ([
      '满级攻击', '满级生命', '满级防御', '满级法术抗性',
      '星级', '攻击间隔', '身高', '稀有度', '部署费用', '阻挡数', '上线年份'
    ].includes(tag)) {
      const gVal = getEffectiveValue(guessed, tag, potentialMode, trustMode);
      const tVal = getEffectiveValue(target, tag, potentialMode, trustMode);
      if (gVal === tVal) {
        comparison[tag] = {
          match: true,
          guessedValue: gVal,
          targetValue: tVal
        };
      } else {
        const direction = gVal < tVal ? 'higher' : 'lower';
        const diff = Math.abs(gVal - tVal);
        let differenceType = 'far';
        if (tVal < 10) {
          if (diff <= 1) differenceType = 'close';
        } else {
          if (diff <= tVal * 0.1) differenceType = 'close';
        }
        comparison[tag] = {
          match: false,
          direction,
          differenceType,
          guessedValue: gVal,
          targetValue: tVal
        };
      }
    }
    else {
      // 普通字段
      comparison[tag] = (guessed[tag] === target[tag]);
    }
  });

  return comparison;
}

/**
 * 比较出生日期：可能存在部分月/日匹配
 */
function compareBirthdays(guessBD, targetBD) {
  if (!guessBD || !targetBD) return false;
  const pattern = /^(\d+)月(\d+)日$/;
  const gMatch = guessBD.match(pattern);
  const tMatch = targetBD.match(pattern);
  if (gMatch && tMatch) {
    const guessTokens = [`${gMatch[1]}月`, `${gMatch[2]}日`];
    const targetTokens = [`${tMatch[1]}月`, `${tMatch[2]}日`];
    const correctTokens = guessTokens.filter(g => targetTokens.includes(g));
    return {
      isBirthday: true,
      guessTokens,
      targetTokens,
      correctTokens
    };
  } else {
    return guessBD === targetBD;
  }
}

=== FILE END: ./src/logic/gameLogic.js ===

=== FILE START: ./src/logic/puzzleService.js ===
// src/logic/puzzleService.js
import { getImagePath } from '../utils/imageUtils';

/**
 * 生成可用的立绘文件名列表
 */
export function getAvailableArts(operator) {
    const arts = [];
    // 基本立绘
    arts.push(`立绘_${operator.干员}_1.png`);
    // 若星级 >= 3 则加立绘_2
    if ((operator.星级 || 0) >= 3) {
        arts.push(`立绘_${operator.干员}_2.png`);
    }
    // 皮肤 (1..10)
    for (let i = 1; i <= 10; i++) {
        const s = operator[`皮肤${i}名称`];
        if (s) {
            arts.push(`立绘_${operator.干员}_skin${i}.png`);
        }
    }
    return arts;
}

/**
 * 从干员的可用立绘随机选择一张
 */
export function selectRandomArt(operator) {
    const list = getAvailableArts(operator);
    if (!list || list.length === 0) {
        return '';
    }
    const idx = Math.floor(Math.random() * list.length);
    return list[idx];
}

/**
 * 加载图片并生成积分图 (integral image) 数据，以便高效计算区域平均颜色。
 */
export async function loadPuzzleImage(operator, maxWidth = 600, maxHeight = 600, initialViewportWidth = 800) {
    return new Promise((resolve, reject) => {
        const fileName = selectRandomArt(operator);
        const puzzleImageUrl = getImagePath(fileName);

        const img = new Image();
        img.crossOrigin = 'anonymous';

        img.onload = () => {
            const imgWidth = img.naturalWidth;
            const imgHeight = img.naturalHeight;

            // 计算缩放后的显示尺寸（不影响积分图生成，只是界面上展示要用）
            const { scaledW, scaledH } = calcScaledDimensions(imgWidth, imgHeight, maxWidth, maxHeight, initialViewportWidth);

            // 可以根据需要再进一步缩小原图，以减少积分图的大小
            const shrinkLimit = 800;
            let finalWidth = imgWidth;
            let finalHeight = imgHeight;
            if (finalWidth > shrinkLimit || finalHeight > shrinkLimit) {
                const scale = shrinkLimit / Math.max(finalWidth, finalHeight);
                finalWidth = Math.floor(finalWidth * scale);
                finalHeight = Math.floor(finalHeight * scale);
            }

            // 用 canvas 缩放到 (finalWidth, finalHeight) 后再取像素
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = finalWidth;
            tempCanvas.height = finalHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0, finalWidth, finalHeight);

            const imageData = tempCtx.getImageData(0, 0, finalWidth, finalHeight);

            // 生成积分图
            const integralData = createIntegralImage(imageData);

            resolve({
                imgWidth: finalWidth,
                imgHeight: finalHeight,
                scaledWidth: scaledW,
                scaledHeight: scaledH,
                puzzleImageUrl,
                integralData
            });
        };

        img.onerror = (err) => {
            reject(err);
        };

        img.src = puzzleImageUrl;
    });
}

/**
 * 计算缩放后的显示尺寸（只是为了界面展示用，与生成积分图无关）
 */
function calcScaledDimensions(w, h, maxW, maxH, viewportWidth) {
    const containerWidth = Math.min(viewportWidth - 30, maxW);

    let scaledW = w;
    let scaledH = h;

    if (w > containerWidth || h > maxH) {
        const scaleW = containerWidth / w;
        const scaleH = maxH / h;
        const scale = Math.min(scaleW, scaleH);
        scaledW = Math.floor(w * scale);
        scaledH = Math.floor(h * scale);
    }

    return { scaledW, scaledH };
}

/**
 * 生成积分图（包含 R/G/B/alphaCount 的前缀和）
 */
export function createIntegralImage(imageData) {
    const { width, height, data } = imageData;

    const sumR = new Uint32Array(width * height);
    const sumG = new Uint32Array(width * height);
    const sumB = new Uint32Array(width * height);
    const alphaCount = new Uint32Array(width * height);

    for (let y = 0; y < height; y++) {
        let rowSumR = 0, rowSumG = 0, rowSumB = 0, rowAlphaCount = 0;
        for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            const r = data[idx];
            const g = data[idx + 1];
            const b = data[idx + 2];
            const a = data[idx + 3];

            if (a > 0) {
                rowSumR += r;
                rowSumG += g;
                rowSumB += b;
                rowAlphaCount += 1;
            }

            const aboveIndex = (y - 1) * width + x;
            if (y > 0) {
                sumR[y * width + x] = sumR[aboveIndex] + rowSumR;
                sumG[y * width + x] = sumG[aboveIndex] + rowSumG;
                sumB[y * width + x] = sumB[aboveIndex] + rowSumB;
                alphaCount[y * width + x] = alphaCount[aboveIndex] + rowAlphaCount;
            } else {
                sumR[y * width + x] = rowSumR;
                sumG[y * width + x] = rowSumG;
                sumB[y * width + x] = rowSumB;
                alphaCount[y * width + x] = rowAlphaCount;
            }
        }
    }

    return {
        sumR,
        sumG,
        sumB,
        alphaCount,
        width,
        height
    };
}

function getIntegralSums(integral, x2, y2) {
    const idx = y2 * integral.width + x2;
    return {
        r: integral.sumR[idx],
        g: integral.sumG[idx],
        b: integral.sumB[idx],
        a: integral.alphaCount[idx]
    };
}

/**
 * 计算某区域的平均颜色
 */
function computeRegionAverage(integral, x1, y1, x2, y2) {
    if (x1 > x2) [x1, x2] = [x2, x1];
    if (y1 > y2) [y1, y2] = [y2, y1];
    if (x1 < 0) x1 = 0;
    if (y1 < 0) y1 = 0;
    if (x2 >= integral.width) x2 = integral.width - 1;
    if (y2 >= integral.height) y2 = integral.height - 1;

    const areaWidth = x2 - x1 + 1;
    const areaHeight = y2 - y1 + 1;

    const A = getIntegralSums(integral, x2, y2);
    const leftSum = x1 > 0 ? getIntegralSums(integral, x1 - 1, y2) : { r: 0, g: 0, b: 0, a: 0 };
    const C = y1 > 0 ? getIntegralSums(integral, x2, y1 - 1) : { r: 0, g: 0, b: 0, a: 0 };

    let r = A.r - leftSum.r - C.r;
    let g = A.g - leftSum.g - C.g;
    let b = A.b - leftSum.b - C.b;
    let a = A.a - leftSum.a - C.a;

    if (x1 > 0 && y1 > 0) {
        const D = getIntegralSums(integral, x1 - 1, y1 - 1);
        r += D.r;
        g += D.g;
        b += D.b;
        a += D.a;
    }

    const totalPixels = areaWidth * areaHeight;
    const alphaRatio = a / totalPixels;
    const MIN_OPACITY_RATIO = 0.15;
    if (alphaRatio < MIN_OPACITY_RATIO) {
        return 'rgb(255,255,255)';
    }
    if (a === 0) {
        return 'rgb(255,255,255)';
    }
    const R = Math.round(r / a);
    const G = Math.round(g / a);
    const B = Math.round(b / a);

    return `rgb(${R},${G},${B})`;
}

/**
 * 计算某个区块在 alpha 通道上的覆盖率
 */
function calcBlockAlphaCoverage(integral, block, scaledWidth, scaledHeight) {
    const ratioX = integral.width / scaledWidth;
    const ratioY = integral.height / scaledHeight;

    const x1 = Math.floor(block.x * ratioX);
    const y1 = Math.floor(block.y * ratioY);
    const x2 = Math.floor((block.x + block.width) * ratioX) - 1;
    const y2 = Math.floor((block.y + block.height) * ratioY) - 1;

    if (x1 > x2 || y1 > y2 || x2 < 0 || y2 < 0) {
        return 0;
    }

    const A = getIntegralSums(integral, x2, y2);
    const leftSum = x1 > 0 ? getIntegralSums(integral, x1 - 1, y2) : { a: 0 };
    const upSum = y1 > 0 ? getIntegralSums(integral, x2, y1 - 1) : { a: 0 };

    let alphaTotal = A.a - leftSum.a - upSum.a;
    if (x1 > 0 && y1 > 0) {
        const corner = getIntegralSums(integral, x1 - 1, y1 - 1);
        alphaTotal += corner.a;
    }

    const areaWidth = x2 - x1 + 1;
    const areaHeight = y2 - y1 + 1;
    const totalPixels = areaWidth * areaHeight;
    if (totalPixels <= 0) return 0;

    return alphaTotal / totalPixels;
}

/**
 * 为单个 block 赋值它的 color、skipRefine 等信息
 */
function assignBlockAttributes(block, integralData, scaledWidth, scaledHeight, minCoverage = 0.1) {
    // 计算覆盖率
    const coverage = calcBlockAlphaCoverage(integralData, block, scaledWidth, scaledHeight);
    if (coverage < minCoverage) {
        block.skipRefine = true;
    }
    // 计算颜色
    const ratioX = integralData.width / scaledWidth;
    const ratioY = integralData.height / scaledHeight;
    const origX1 = Math.floor(block.x * ratioX);
    const origY1 = Math.floor(block.y * ratioY);
    const origX2 = Math.floor((block.x + block.width) * ratioX) - 1;
    const origY2 = Math.floor((block.y + block.height) * ratioY) - 1;
    block.color = computeRegionAverage(integralData, origX1, origY1, origX2, origY2);
}

/**
 * 初始化 blocks 并计算它们的 color
 */
export function initBlocks(scaledWidth, scaledHeight, initialGridSize, integralData = null, minCoverage = 0.01) {
    const blocks = [];
    const { rows, cols } = initialGridSize;
    const blockWidth = scaledWidth / cols;
    const blockHeight = scaledHeight / rows;

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const block = {
                row,
                col,
                x: col * blockWidth,
                y: row * blockHeight,
                width: blockWidth,
                height: blockHeight,
                initialRow: row,
                initialCol: col,
                level: 1,
                skipRefine: false
            };
            if (integralData) {
                assignBlockAttributes(block, integralData, scaledWidth, scaledHeight, minCoverage);
            }
            blocks.push(block);
        }
    }
    return blocks;
}

/**
 * 细化：把某区域内的所有 block 划分成更小的 block
 */
export function refineAreaBlocks(
    blocks,
    initialRow,
    initialCol,
    refinementFactor,
    integralData = null,
    scaledWidth = 0,
    scaledHeight = 0,
    minCoverage = 0.01
) {
    const { rows: refRows, cols: refCols } = refinementFactor;

    // 找出此区域(初始row/col)的所有 block
    const subBlocks = blocks.filter(b => b.initialRow === initialRow && b.initialCol === initialCol);

    // 删除旧块
    const indicesToRemove = subBlocks.map(sb => blocks.indexOf(sb)).filter(i => i >= 0);
    indicesToRemove.sort((x, y) => y - x);
    indicesToRemove.forEach(idx => blocks.splice(idx, 1));

    subBlocks.forEach(block => {
        // 若已经 skipRefine，就不再细分
        if (block.skipRefine) {
            block.level += 1;
            blocks.push(block);
            return;
        }

        // 细化
        const newW = block.width / refCols;
        const newH = block.height / refRows;
        for (let r = 0; r < refRows; r++) {
            for (let c = 0; c < refCols; c++) {
                const newBlock = {
                    row: block.row * refRows + r,
                    col: block.col * refCols + c,
                    x: block.x + c * newW,
                    y: block.y + r * newH,
                    width: newW,
                    height: newH,
                    initialRow,
                    initialCol,
                    level: block.level + 1,
                    skipRefine: false
                };
                if (integralData && scaledWidth > 0 && scaledHeight > 0) {
                    assignBlockAttributes(newBlock, integralData, scaledWidth, scaledHeight, minCoverage);
                }
                blocks.push(newBlock);
            }
        }
    });
}

/**
 * 随机细化 blocks
 */
export function refineRandomBlocks(
    blocks, 
    areaRefinementLevels, 
    refinementCount, 
    refinementFactor, 
    initialGridSize,
    integralData = null,
    scaledWidth = 0,
    scaledHeight = 0,
    minCoverage = 0.01
) {
    let needed = refinementCount;
    const { rows, cols } = initialGridSize;

    const allAreas = [];
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            allAreas.push({
                row: r, col: c,
                level: areaRefinementLevels[`${r},${c}`] || 0
            });
        }
    }

    // 按照细化等级升序
    allAreas.sort((u, v) => u.level - v.level);

    let idx = 0;
    while (needed > 0 && idx < allAreas.length) {
        const currLevel = allAreas[idx].level;
        const sameLevelGroup = allAreas.filter(a => a.level === currLevel);

        if (sameLevelGroup.length <= needed) {
            sameLevelGroup.forEach(a => {
                refineAreaBlocks(
                    blocks, 
                    a.row, 
                    a.col, 
                    refinementFactor, 
                    integralData, 
                    scaledWidth, 
                    scaledHeight,
                    minCoverage
                );
                areaRefinementLevels[`${a.row},${a.col}`] = currLevel + 1;
            });
            needed -= sameLevelGroup.length;
            idx += sameLevelGroup.length;
        } else {
            for (let i = 0; i < needed; i++) {
                const randIdx = Math.floor(Math.random() * sameLevelGroup.length);
                const area = sameLevelGroup.splice(randIdx, 1)[0];
                refineAreaBlocks(
                    blocks, 
                    area.row, 
                    area.col, 
                    refinementFactor,
                    integralData,
                    scaledWidth,
                    scaledHeight,
                    minCoverage
                );
                areaRefinementLevels[`${area.row},${area.col}`] = area.level + 1;
            }
            needed = 0;
        }
    }
}

/**
 * 根据当前 blocks，使用 block.color 一次性绘制马赛克
 */
export function renderMosaic(ctx, blocks, integralData, scaledWidth, scaledHeight) {
    ctx.clearRect(0, 0, scaledWidth, scaledHeight);

    blocks.forEach(block => {
        ctx.fillStyle = block.color;
        ctx.fillRect(block.x, block.y, block.width, block.height);
    });
}

=== FILE END: ./src/logic/puzzleService.js ===

=== FILE START: ./src/utils/dataLoader.js ===
// src/utils/dataLoader.js

/**
 * 从本地JSON文件加载干员数据
 * @param {string} filePath - JSON文件路径
 * @returns {Promise<Array>} - 干员数据数组
 */
export async function loadOperatorsData(filePath = './data/operators.json') {
  try {
    const response = await fetch(filePath);
    if (!response.ok) {
      throw new Error(`Failed to load operators data: ${response.status}`);
    }
    const data = await response.json();
    console.log(`成功加载了 ${data.length} 个干员数据`);
    return data;
  } catch (error) {
    console.error('加载干员数据失败:', error);
    throw error;
  }
}

/**
 * 从字符串生成干员拼音首字母索引 (可选)
 * 不改也行
 */
export function generatePinyinIndex(operators) {
  return {};
}

/**
 * 根据条件过滤干员数据 (可选)
 */
export function filterOperators(operators, filters) {
  // ...
  return operators;
}

/**
 * 创建自定义标签组合 (可选)
 */
export function createTagGroup(id, name, description, tags) {
  return {
    id, name, description, tags
  };
}

=== FILE END: ./src/utils/dataLoader.js ===

=== FILE START: ./src/utils/imageUtils.js ===
// utils/imageUtils.js
import MD5 from "md5";

export const MEDIA_ENDPOINT = "https://media.prts.wiki";

// 使用 MD5 来构造图片路径
export function getImagePath(filename) {
  const md5 = MD5(filename);
  return `${MEDIA_ENDPOINT}/${md5.slice(0, 1)}/${md5.slice(0, 2)}/${filename}`;
}

/**
 * 获取干员头像文件名
 * 当干员稀有度 >= 3 时，使用 头像_干员名_2.png，否则使用 头像_干员名.png
 */
export function getOperatorAvatarFile(operatorName, rarity) {
  const r = parseInt(rarity, 10);
  if (r >= 3) {
    return `头像_${operatorName}_2.png`;
  } else {
    return `头像_${operatorName}.png`;
  }
}

/**
 * 稀有度图标文件名: 稀有度_黄_x.png
 */
export function getRarityIconFile(rarity) {
  return `稀有度_黄_${rarity}.png`;
}

/**
 * 职业图标文件名: 图标_职业_职业名.png
 */
export function getProfessionIconFile(profession) {
  return `图标_职业_${profession}.png`;
}

/**
 * 给定稀有度返回对应颜色
 */
export function getRarityColor(rarity) {
  const colorMap = {
    "1": "#bfbfbf",
    "2": "#bfbfbf",
    "3": "#00b0ff",
    "4": "#d6c44c",
    "5": "#ffb800",
    "6": "#ff8000"
  };
  return colorMap[rarity] || "#bfbfbf";
}

// 返回立绘列表
export function getOperatorLihuiList(operator) {
  const rarity = parseInt(operator.稀有度, 10) || 0;
  const baseList = [];

  // 精英1一定有
  baseList.push(`立绘_${operator.干员}_1.png`);

  // 如果稀有度 >= 3，可能有精英2
  if (rarity >= 3) {
    baseList.push(`立绘_${operator.干员}_2.png`);
  }

  // 皮肤 1~10
  for (let i = 1; i <= 10; i++) {
    const skinName = operator[`皮肤${i}名称`];
    if (skinName) {
      baseList.push(`立绘_${operator.干员}_skin${i}.png`);
    }
  }

  return baseList;
}

=== FILE END: ./src/utils/imageUtils.js ===

=== FILE START: ./src/utils/cookieSettings.js ===
import Cookies from 'js-cookie';

const SETTINGS_COOKIE_KEY = 'arknightsWordle.settings';

export function saveSettings(settings) {
  try {
    Cookies.set(SETTINGS_COOKIE_KEY, JSON.stringify(settings), { expires: 365 });
  } catch (error) {
    console.error('保存游戏设置到Cookie失败:', error);
  }
}

export function loadSettings() {
  try {
    const raw = Cookies.get(SETTINGS_COOKIE_KEY);
    if (raw) {
      return JSON.parse(raw);
    }
  } catch (error) {
    console.error('从Cookie加载游戏设置失败:', error);
  }
  return {};
}

=== FILE END: ./src/utils/cookieSettings.js ===

=== FILE START: ./src/AppWrapper.vue ===
=== FILE START: ./src/AppWrapper.vue ===
<template>
  <div class="app-wrapper">
    <router-view />
  </div>
</template>

<script>
export default {
  name: 'AppWrapper'
}
</script>

<style>
/* 全局或通用样式（如果需要） */
.app-wrapper {
  width: 100%;
  min-height: 100vh;
  background: var(--background-color);
}
</style>
=== FILE END: ./src/AppWrapper.vue ===

=== FILE END: ./src/AppWrapper.vue ===

=== FILE START: ./src/main.js ===
// src/main.js
import { createApp } from 'vue';
import App from './App.vue';

// 引入全局变量CSS
import './styles/variables.css';

// 初始化主题
import { initTheme } from './themes';
initTheme();

createApp(App).mount('#app');

=== FILE END: ./src/main.js ===

=== FILE START: ./src/components/GuessInput.vue ===
<template>
  <div class="guess-input-container">
    <div class="input-wrapper">
      <div class="search-icon">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
        </svg>
      </div>
      <input
        ref="searchInput"
        type="text"
        v-model="searchTerm"
        @input="onSearchInput"
        @focus="showSuggestions = true"
        @keydown.enter.prevent="submitSelectedOperator"
        @keydown.down.prevent="navigateSuggestion(1)"
        @keydown.up.prevent="navigateSuggestion(-1)"
        @keydown.esc="showSuggestions = false"
        placeholder="输入干员名称或拼音..."
        :disabled="disabled"
        class="operator-search-input"
        autocomplete="off"
      />
      <button @click="submitSelectedOperator" :disabled="disabled || !canSubmit" class="submit-button">
        提交
      </button>
    </div>

    <div v-if="showSuggestions && filteredOperators.length > 0" class="suggestions-dropdown">
      <div
        v-for="(operator, index) in filteredOperators"
        :key="operator.干员"
        @click="selectOperator(operator)"
        class="suggestion-item"
        :class="{ 'active': index === activeIndex }"
      >
        <div class="operator-avatar-container">
          <img :src="getOperatorAvatar(operator)" class="operator-avatar" :alt="operator.干员" />
          <div
            class="operator-rarity-badge"
            :style="{ backgroundColor: getRarityColor(operator.稀有度) }"
          >
            {{ operator.星级 }}★
          </div>
        </div>

        <div class="operator-info">
          <span class="operator-name">{{ operator.干员 }}</span>
          <div class="operator-details">
            <span v-if="isChinese(operator.干员)" class="operator-pinyin">{{ getPinyinDisplay(operator) }}</span>
            <span class="operator-profession">{{ operator.职业 }}</span>
          </div>
        </div>
      </div>
    </div>

    <div v-if="showSuggestions && searchTerm && filteredOperators.length === 0" class="no-results">
      未找到匹配的干员
    </div>
  </div>
</template>

<script>
import { ref, computed, watch, onMounted, onBeforeUnmount } from 'vue';
import { pinyin } from 'pinyin-pro';
import { getOperatorAvatarFile, getImagePath, getRarityColor } from '../utils/imageUtils';

export default {
  name: 'GuessInput',
  props: {
    operators: {
      type: Array,
      required: true
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ['submit'],
  setup(props, { emit }) {
    const searchInput = ref(null);
    const searchTerm = ref('');
    const selectedOperator = ref(null);
    const showSuggestions = ref(false);
    const activeIndex = ref(0);

    const operatorPinyinMap = ref({});

    const generatePinyinMap = () => {
      const map = {};
      props.operators.forEach(op => {
        if (isChinese(op.干员)) {
          const fullPinyin = pinyin(op.干员, { toneType: 'none', type: 'string' });
          const firstLetters = pinyin(op.干员, { pattern: 'first', toneType: 'none', type: 'string' });
          map[op.干员] = {
            full: fullPinyin.toLowerCase(),
            first: firstLetters.toLowerCase()
          };
        }
      });
      operatorPinyinMap.value = map;
    };

    const isChinese = (str) => {
      return /[\u4e00-\u9fa5]/.test(str);
    };

    const searchOperators = (term) => {
      if (!term.trim()) return [];
      const searchLower = term.toLowerCase();
      const results = [];

      props.operators.forEach(op => {
        let matched = false;
        const nameLower = op.干员.toLowerCase();
        if (nameLower.includes(searchLower)) {
          matched = true;
        } else if (isChinese(op.干员) && operatorPinyinMap.value[op.干员]) {
          const pinyinData = operatorPinyinMap.value[op.干员];
          if (pinyinData.full.includes(searchLower) || pinyinData.first.includes(searchLower)) {
            matched = true;
          }
        }
        if (matched) {
          results.push(op);
        }
      });

      // 简单排序：名称直接包含 > 拼音匹配
      return results.sort((a, b) => {
        const aLower = a.干员.toLowerCase();
        const bLower = b.干员.toLowerCase();
        const aDirect = aLower.includes(searchLower);
        const bDirect = bLower.includes(searchLower);
        if (aDirect && !bDirect) return -1;
        if (!aDirect && bDirect) return 1;
        return a.干员.length - b.干员.length;
      });
    };

    const filteredOperators = computed(() => {
      if (!searchTerm.value.trim()) return [];
      return searchOperators(searchTerm.value).slice(0, 8);
    });

    const canSubmit = computed(() => {
      return selectedOperator.value || filteredOperators.value.length === 1;
    });

    const onSearchInput = () => {
      selectedOperator.value = null;
      showSuggestions.value = true;
      activeIndex.value = 0;
    };

    const selectOperator = (operator) => {
      selectedOperator.value = operator;
      searchTerm.value = operator.干员;
      showSuggestions.value = false;
    };

    const submitSelectedOperator = () => {
      if (!selectedOperator.value && filteredOperators.value.length === 1) {
        selectOperator(filteredOperators.value[0]);
      } else if (!selectedOperator.value && filteredOperators.value.length > 1) {
        selectOperator(filteredOperators.value[activeIndex.value]);
      }
      if (selectedOperator.value) {
        emit('submit', selectedOperator.value.干员);
        searchTerm.value = '';
        selectedOperator.value = null;
        setTimeout(() => {
          searchInput.value?.focus();
        }, 100);
      }
    };

    const navigateSuggestion = (direction) => {
      if (filteredOperators.value.length === 0) return;
      let newIndex = activeIndex.value + direction;
      if (newIndex < 0) newIndex = filteredOperators.value.length - 1;
      if (newIndex >= filteredOperators.value.length) newIndex = 0;
      activeIndex.value = newIndex;
    };

    const getOperatorAvatar = (operator) => {
      const file = getOperatorAvatarFile(operator.干员, operator.稀有度);
      return getImagePath(file);
    };

    const getPinyinDisplay = (operator) => {
      if (!isChinese(operator.干员)) return '';
      const data = operatorPinyinMap.value[operator.干员];
      return data ? data.full : '';
    };

    const handleClickOutside = (event) => {
      const container = document.querySelector('.guess-input-container');
      if (container && !container.contains(event.target)) {
        showSuggestions.value = false;
      }
    };

    watch(showSuggestions, val => {
      if (val) {
        setTimeout(() => {
          window.addEventListener('click', handleClickOutside);
        }, 0);
      } else {
        window.removeEventListener('click', handleClickOutside);
      }
    });

    onMounted(() => {
      generatePinyinMap();
      searchInput.value?.focus();
    });
    onBeforeUnmount(() => {
      window.removeEventListener('click', handleClickOutside);
    });

    return {
      searchInput,
      searchTerm,
      selectedOperator,
      showSuggestions,
      activeIndex,
      canSubmit,
      filteredOperators,
      onSearchInput,
      selectOperator,
      submitSelectedOperator,
      navigateSuggestion,
      getOperatorAvatar,
      getRarityColor,
      getPinyinDisplay,
      isChinese
    };
  }
};
</script>

<style>
.guess-input-container {
  position: relative;
  width: 100%;
  z-index: 100;
}

.input-wrapper {
  display: flex;
  position: relative;
  align-items: center;
  border-radius: 8px;
  background-color: var(--color-card-bg);
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
}

.search-icon {
  position: absolute;
  left: 16px;
  color: #8c9db5;
  display: flex;
  align-items: center;
}

.operator-search-input {
  flex: 1;
  padding: 16px 16px 16px 48px;
  font-size: 16px;
  border: 2px solid var(--color-border);
  border-radius: 8px 0 0 8px;
  transition: all var(--transition-duration);
  background-color: transparent;
  color: var(--color-text);
}

.operator-search-input:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

.operator-search-input:disabled {
  background-color: #f5f5f5;
  cursor: not-allowed;
  color: #999;
}

.submit-button {
  padding: 0 28px;
  height: 52px;
  background-color: var(--color-primary);
  color: white;
  border: none;
  border-radius: 0 8px 8px 0;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color var(--transition-duration);
}
.submit-button:hover:not(:disabled) {
  background-color: var(--color-primary-hover);
}
.submit-button:disabled {
  background-color: #bdc3c7;
  cursor: not-allowed;
}

/* 下拉菜单 */
.suggestions-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  margin-top: 8px;
  background-color: var(--color-card-bg);
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  overflow: hidden;
  z-index: 10;
  max-height: 350px;
  overflow-y: auto;
}

.suggestion-item {
  display: flex;
  align-items: center;
  padding: 12px 16px;
  cursor: pointer;
  transition: background-color 0.2s;
  border-bottom: 1px solid var(--color-border);
}
.suggestion-item:hover,
.suggestion-item.active {
  background-color: rgba(255,255,255,0.1);
}
.suggestion-item:last-child {
  border-bottom: none;
}

.operator-avatar-container {
  width: 48px;
  height: 48px;
  margin-right: 16px;
  border-radius: 50%;
  overflow: hidden;
  background-color: #f0f0f0;
  position: relative;
}

.operator-avatar {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.operator-rarity-badge {
  position: absolute;
  bottom: -2px;
  right: -2px;
  border-radius: 10px;
  padding: 1px 5px;
  font-size: 10px;
  font-weight: bold;
  color: white;
  background-color: #ffb800;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.operator-info {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.operator-name {
  font-weight: 600;
  font-size: 16px;
  margin-bottom: 2px;
  color: var(--color-text);
}

.operator-details {
  display: flex;
  font-size: 12px;
  color: #888;
  gap: 8px;
}

.operator-profession {
  background-color: #eef2f7;
  padding: 1px 6px;
  border-radius: 4px;
  font-weight: 500;
}

.operator-pinyin {
  color: #8c9db5;
  font-style: italic;
}

/* 无结果提示 */
.no-results {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  margin-top: 8px;
  padding: 16px;
  background-color: var(--color-card-bg);
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  text-align: center;
  color: #888;
}

/* 响应式 */
@media (max-width: 768px) {
  .operator-search-input {
    font-size: 14px;
    padding: 12px 12px 12px 40px;
    height: 44px;
  }
  .submit-button {
    font-size: 14px;
    padding: 0 16px;
    height: 44px;
  }
  .operator-avatar-container {
    width: 36px;
    height: 36px;
    margin-right: 10px;
  }
  .suggestion-item {
    padding: 8px 12px;
  }
  .operator-name {
    font-size: 14px;
  }
}
</style>

=== FILE END: ./src/components/GuessInput.vue ===

=== FILE START: ./src/components/GameBoard.vue ===
<template>
  <div class="game-board">
    <div class="game-status">
      <template v-if="gameWon">
        <div class="status-message win">
          <span>恭喜你猜对了！答案是 {{ targetOperator.干员 }}</span>
        </div>
      </template>
      <template v-else-if="userGaveUp">
        <div class="status-message lose">
          <span>你已放弃游戏！正确答案是 {{ targetOperator.干员 }}</span>
        </div>
      </template>
      <template v-else-if="gameOver && !userGaveUp">
        <div class="status-message lose">
          <span>游戏结束！正确答案是 {{ targetOperator.干员 }}</span>
        </div>
      </template>
      <template v-else>
        <div class="attempts-counter">
          已猜次数: {{ guesses.length }} / {{ maxGuesses }}
        </div>
      </template>
    </div>

    <div class="results-section">
      <div class="results-table">
        <div class="header-row">
          <div class="header-cell cell-avatar">干员</div>
          <div
            v-for="tag in displayTags"
            :key="tag"
            class="header-cell"
          >
            {{ tag }}
          </div>
        </div>

        <div class="results-body">
          <result-row
            v-for="(guess, index) in guesses"
            :key="index"
            :guess="guess"
            :comparison="comparisons[index]"
            :displayTags="displayTags"
          />

          <!-- 若用尽次数/放弃且没猜中 => 显示答案行 -->
          <result-row
            v-if="(gameOver && !gameWon) || userGaveUp"
            :guess="targetOperator"
            :comparison="answerComparison"
            :displayTags="displayTags"
            :isAnswerRow="true"
          />
        </div>
      </div>
    </div>

    <div class="game-controls">
      <button
        v-if="gameOver || gameWon"
        @click="handleReset"
        class="reset-button"
      >
        重新开始
      </button>
    </div>
  </div>
</template>

<script>
import { computed } from 'vue';
import ResultRow from './ResultRow.vue';
import { getEffectiveValue } from '../logic/gameLogic';

export default {
  name: 'GameBoard',
  components: {
    ResultRow
  },
  props: {
    operatorData: {
      type: Array,
      required: true
    },
    guesses: {
      type: Array,
      required: true
    },
    comparisons: {
      type: Array,
      required: true
    },
    targetOperator: {
      type: Object,
      required: true
    },
    gameOver: {
      type: Boolean,
      required: true
    },
    gameWon: {
      type: Boolean,
      required: true
    },
    maxGuesses: {
      type: Number,
      required: true
    },
    userGaveUp: {
      type: Boolean,
      default: false
    },
    potentialMode: {
      type: String,
      default: '0潜'
    },
    trustMode: {
      type: String,
      default: '0信赖'
    },
    selectedTagGroup: {
      type: Object,
      required: false
    }
  },
  emits: ['reset'],
  setup(props, { emit }) {
    const displayTags = computed(() => {
      if (!props.selectedTagGroup) return [];
      return props.selectedTagGroup.tags || [];
    });

    const handleReset = () => {
      emit('reset');
    };

    // 答案行的对比对象
    const answerComparison = computed(() => {
      return compareAsAnswer(props.targetOperator, displayTags.value, props.potentialMode, props.trustMode);
    });

    function compareAsAnswer(op, tags, potentialMode, trustMode) {
      const comp = {};
      tags.forEach((tag) => {
        if (tag === '标签') {
          const allTags = op[tag]?.split(' ').map(s => s.trim()).filter(Boolean) || [];
          comp[tag] = {
            guessTags: allTags,
            targetTags: allTags,
            correctTags: allTags
          };
        } else if (tag === '出生日期') {
          comp[tag] = true;
        } else if (
          [
            '稀有度',
            '满级攻击',
            '满级生命',
            '满级防御',
            '满级法术抗性',
            '部署费用',
            '阻挡数',
            '星级',
            '攻击间隔',
            '身高'
          ].includes(tag)
        ) {
          const val = getEffectiveValue(op, tag, potentialMode, trustMode);
          comp[tag] = {
            match: true,
            guessedValue: val,
            targetValue: val
          };
        } else {
          comp[tag] = true;
        }
      });
      return comp;
    }

    return {
      displayTags,
      answerComparison,
      handleReset
    };
  }
};
</script>

<style>
.game-board {
  display: flex;
  flex-direction: column;
  gap: 20px;
  transition: background-color var(--transition-duration);
}

.game-status {
  text-align: center;
  margin-bottom: 10px;
}

.status-message {
  padding: 12px;
  border-radius: 6px;
  font-weight: bold;
  font-size: 18px;
  word-wrap: break-word;
  white-space: normal;
  margin: 0 auto;
  max-width: 600px;
}

.win {
  background-color: var(--color-win-bg);
  color: var(--color-win-text);
}

.lose {
  background-color: var(--color-lose-bg);
  color: var(--color-lose-text);
}

.attempts-counter {
  font-size: 18px;
  color: var(--color-text);
  font-weight: 500;
}

.results-section {
  margin-top: 15px;
  border-radius: 12px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  overflow-x: auto;
  background-color: var(--color-card-bg);
  padding: 8px;
}

.results-table {
  display: table;
  width: 100%;
  table-layout: auto;
  border-collapse: separate;
  border-spacing: 0 2px;
}

.header-row {
  display: table-row;
  background-color: rgba(255, 255, 255, 0.1);
}

.header-cell {
  display: table-cell;
  padding: 12px;
  text-align: center;
  font-weight: 600;
  border-bottom: 1px solid var(--color-border);
  color: var(--color-text);
}
.cell-avatar {
  width: 100px;
}

.results-body {
  display: table-row-group;
}

.game-controls {
  margin-top: 20px;
  display: flex;
  justify-content: center;
}

.reset-button {
  padding: 10px 24px;
  font-size: 16px;
  font-weight: 500;
  background-color: var(--color-primary);
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color var(--transition-duration);
}
.reset-button:hover {
  background-color: var(--color-primary-hover);
}

@media (max-width: 768px) {
  .attempts-counter {
    font-size: 16px;
  }
  .status-message {
    font-size: 16px;
    padding: 8px;
  }
  .header-cell {
    font-size: 13px;
    padding: 8px;
  }
  .cell-avatar {
    width: 60px;
  }
}
</style>

=== FILE END: ./src/components/GameBoard.vue ===

=== FILE START: ./src/components/ResultRow.vue ===
<template>
  <div class="result-row" :class="{ 'answer-row': isAnswerRow }">
    <div class="result-cell cell-avatar">
      <div class="avatar-container">
        <img :src="getOperatorAvatar(guess)" class="operator-avatar" :alt="guess.干员" />
      </div>
      <div class="operator-name desktop-only">{{ guess.干员 }}</div>
    </div>

    <template v-for="tag in displayTags" :key="tag">
      <!-- 标签字段 -->
      <div
        v-if="tag === '标签'"
        class="result-cell tag-cell"
        :class="getTagCellClass(comparison[tag])"
      >
        <div class="tags-container">
          <span
            v-for="gTag in comparison[tag].guessTags"
            :key="gTag"
            :class="{ 'tag-match': comparison[tag].correctTags.includes(gTag) }"
          >
            {{ gTag }}
          </span>
        </div>
      </div>

      <!-- 出生日期：部分匹配/或简单true -->
      <div
        v-else-if="isBirthdayComparison(comparison[tag])"
        class="result-cell tag-cell"
        :class="getTagCellClass(comparison[tag])"
      >
        <div class="tags-container">
          <span
            v-for="token in comparison[tag].guessTokens"
            :key="token"
            :class="{ 'tag-match': comparison[tag].correctTokens.includes(token) }"
          >
            {{ token }}
          </span>
        </div>
      </div>
      <div
        v-else-if="tag === '出生日期'"
        class="result-cell"
        :class="getCellClass(comparison[tag])"
      >
        {{ guess[tag] }}
      </div>

      <!-- 数值型字段 -->
      <div
        v-else-if="isNumericTag(tag)"
        class="result-cell"
        :class="getNumericCellClass(comparison[tag])"
      >
        <div class="cell-content">
          <template v-if="comparison[tag] === true">
            {{ guess[tag] }}
          </template>
          <template v-else-if="typeof comparison[tag] === 'object' && comparison[tag] !== null">
            {{ comparison[tag].guessedValue }}
            <span
              v-if="!comparison[tag].match"
              class="direction-indicator"
              :class="{
                'higher-arrow': comparison[tag].direction === 'higher',
                'lower-arrow': comparison[tag].direction === 'lower'
              }"
            >
              {{ comparison[tag].direction === 'higher' ? '↑' : '↓' }}
            </span>
          </template>
        </div>
      </div>

      <!-- 普通字符串 -->
      <div
        v-else
        class="result-cell"
        :class="getCellClass(comparison[tag])"
      >
        <template v-if="comparison[tag] === true">
          {{ guess[tag] }}
        </template>
        <template v-else-if="typeof comparison[tag] === 'boolean'">
          {{ guess[tag] }}
        </template>
        <template v-else>
          {{ guess[tag] }}
        </template>
      </div>
    </template>
  </div>
</template>

<script>
import { getImagePath, getOperatorAvatarFile } from '../utils/imageUtils';

export default {
  name: 'ResultRow',
  props: {
    guess: {
      type: Object,
      required: true
    },
    comparison: {
      type: Object,
      required: true
    },
    displayTags: {
      type: Array,
      required: true
    },
    isAnswerRow: {
      type: Boolean,
      default: false
    }
  },
  setup() {
    /**
     * 判断是否为数值类字段
     */
    const isNumericTag = (tag) => [
      '星级',
      '满级攻击',
      '满级生命',
      '满级防御',
      '满级法术抗性',
      '部署费用',
      '阻挡数',
      '攻击间隔',
      '身高',
      '上线年份'
    ].includes(tag);

    /**
     * 判断是否为出生日期对比对象
     */
    const isBirthdayComparison = (val) => {
      return val && typeof val === 'object' && val.isBirthday;
    };

    /**
     * 普通字段 / 出生日期为 false 时 => incorrect
     * true 时 => correct
     */
    const getCellClass = (res) => {
      if (res === true) return 'correct';
      if (res === false) return 'incorrect';
      return 'incorrect';
    };

    /**
     * 数值型字段，需要判断是完全相等、接近远离、方向等
     */
    const getNumericCellClass = (res) => {
      if (res === true) {
        // 直接命中
        return 'correct';
      }
      if (res && res.match) {
        // 数值相同
        return 'correct';
      }
      if (res && res.direction) {
        // 有方向 => higher/lower; differenceType => close/far
        const { direction, differenceType } = res;
        return `${direction}-${differenceType}`;
      }
      // 其他情况 => incorrect
      return 'incorrect';
    };

    /**
     * 标签字段，若有至少一个重叠 => correct，否则 => incorrect
     */
    const getTagCellClass = (tagComparison) => {
      if (!tagComparison) return 'incorrect';
      if (tagComparison.correctTags && tagComparison.correctTags.length > 0) {
        return 'correct';
      }
      return 'incorrect';
    };

    /**
     * 获取干员头像
     */
    const getOperatorAvatar = (operator) => {
      const filename = getOperatorAvatarFile(operator.干员, operator.稀有度);
      return getImagePath(filename);
    };

    return {
      isNumericTag,
      isBirthdayComparison,
      getCellClass,
      getNumericCellClass,
      getTagCellClass,
      getOperatorAvatar
    };
  }
};
</script>

<style>
.result-row {
  display: table-row;
  width: 100%;
  border-bottom: 1px solid var(--color-border);
  transition: background-color var(--transition-duration);
}

.result-row:last-child {
  border-bottom: none;
}

/* 当此行是正确答案时 */
.answer-row {
  font-weight: 600;
  background-color: rgba(63, 81, 181, 0.08);
}

.result-cell {
  display: table-cell;
  padding: 12px;
  text-align: center;
  vertical-align: middle;
  border-right: 1px solid var(--color-border);
  position: relative;
  font-weight: 500;
  color: var(--color-text);
}
.result-cell:last-child {
  border-right: none;
}

/* 第一列：干员头像 */
.cell-avatar {
  width: 100px;
  background-color: rgba(0,0,0,0.02);
}

.avatar-container {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  overflow: hidden;
  margin-bottom: 6px;
  background-color: #eee;
  border: 2px solid #ddd;
  margin: auto;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

.operator-avatar {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.operator-name {
  font-size: 14px;
  margin-top: 4px;
  color: var(--color-text);
}

/* 数值比对图标/方向 */
.cell-content {
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.direction-indicator {
  margin-left: 3px;
  font-weight: bold;
}

/* 配色方案：改为浅橙、浅红等 */
.correct {
  background-color: rgba(76, 175, 80, 0.2); /* 浅绿色 */
}
.incorrect {
  background-color: rgba(244, 67, 54, 0.2); /* 浅红色 */
}

/* 数值差距为 close => 浅橙色, far => 更红一些 */
.higher-close,
.lower-close {
  background-color: rgba(255, 152, 0, 0.2); /* 浅橙 */
}
.higher-far,
.lower-far {
  background-color: rgba(244, 67, 54, 0.3); /* 浅红(稍深) */
}

/* 箭头颜色：橙色/红色 */
.higher-arrow {
  color: #ff9800;
}
.lower-arrow {
  color: #f44336;
}

/* 标签 / 生日 */
.tag-cell .tags-container {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  justify-content: center;
}
.tag-cell span {
  padding: 2px 6px;
  border-radius: 4px;
  background: #fafafa;
  font-size: 12px;
}
.tag-cell .tag-match {
  background: rgba(76, 175, 80, 0.3);
  font-weight: bold;
}

/* 桌面端额外显示干员名称 */
.desktop-only {
  display: block;
}

/* 移动端适配 */
@media (max-width: 768px) {
  .result-cell {
    padding: 8px;
    font-size: 12px;
  }
  .cell-avatar {
    width: 60px;
  }
  .avatar-container {
    width: 36px;
    height: 36px;
  }
  .operator-name {
    display: none;
  }
}
</style>

=== FILE END: ./src/components/ResultRow.vue ===

=== FILE START: ./src/components/PuzzleBoard.vue ===
<template>
  <div class="puzzle-board">
    <!-- 游戏状态区 -->
    <div class="game-status">
      <template v-if="gameWon">
        <div class="status-message win">
          <span>恭喜你猜对了！答案是 {{ targetOperator.干员 }}</span>
        </div>
      </template>
      <template v-else-if="userGaveUp">
        <div class="status-message lose">
          <span>你已放弃游戏！正确答案是 {{ targetOperator.干员 }}</span>
        </div>
      </template>
      <template v-else-if="gameOver">
        <div class="status-message lose">
          <span>游戏结束！正确答案是 {{ targetOperator.干员 }}</span>
        </div>
      </template>
      <template v-else>
        <div class="attempts-counter">
          已猜次数: {{ guesses.length }} / {{ maxGuesses }}
        </div>
      </template>
    </div>

    <!-- （1）提示信息：在没有结束且没有猜对的情况下，每隔 puzzleHintInterval 次错误猜测，显示一条新提示 -->
    <div v-if="displayedHints.length > 0 && !gameWon && !gameOver && !userGaveUp" class="puzzle-hints">
      <h3>提示信息</h3>
      <ul>
        <li v-for="(hint, idx) in displayedHints" :key="idx">
          <strong>{{ hint.label }}:</strong> {{ hint.value() }}
        </li>
      </ul>
    </div>

    <!-- 图片 / 马赛克显示区域 -->
    <!-- 如果放弃或用完次数但没猜中，则沿用旧的“最终图片”逻辑 -->
    <div v-if="(userGaveUp || (gameOver && !gameWon)) && !loadingImage" class="final-image-container">
      <img
        v-if="puzzleImageUrl"
        :src="puzzleImageUrl"
        :alt="targetOperator.干员"
        class="final-image"
        :style="{ maxWidth: '100%', width: scaledWidth + 'px', maxHeight: scaledHeight + 'px' }"
      />
    </div>

    <!-- 如果猜对，则左侧显示马赛克，右侧显示原图 -->
    <div v-else-if="gameWon && !loadingImage" class="final-compare-container">
      <div class="final-compare-left">
        <!-- 让用户看到最后的马赛克图，渲染到同一个 canvas -->
        <canvas
          ref="mosaicCanvas"
          :width="scaledWidth"
          :height="scaledHeight"
        ></canvas>
      </div>
      <div class="final-compare-right">
        <img
          v-if="puzzleImageUrl"
          :src="puzzleImageUrl"
          :alt="targetOperator.干员"
          class="final-image"
          :style="{ maxWidth: '100%', width: scaledWidth + 'px', maxHeight: scaledHeight + 'px' }"
        />
      </div>
    </div>

    <!-- 如果游戏还在进行，正常显示马赛克（canvas） -->
    <div v-else-if="!loadingImage" class="mosaic-container" :style="{ maxWidth: '100%', width: scaledWidth + 'px', height: scaledHeight + 'px' }">
      <canvas
        ref="mosaicCanvas"
        :width="scaledWidth"
        :height="scaledHeight"
      ></canvas>
    </div>

    <!-- 图片正在加载 -->
    <div v-else class="image-loading-indicator">
      <p>图片加载中...</p>
    </div>

    <!-- 已猜的干员列表 -->
    <div
      class="guesses-container"
      v-if="guesses.length > 0"
    >
      <h4>已猜的干员：</h4>
      <div class="guess-list">
        <div
          v-for="(op, idx) in guesses"
          :key="idx"
          class="guess-item"
          :class="op.干员 === targetOperator.干员 ? 'correct' : 'incorrect'"
        >
          <img
            :src="getOperatorAvatar(op)"
            :alt="op.干员"
            class="guess-avatar"
          />
          <span class="guess-name">{{ op.干员 }}</span>
        </div>
      </div>
    </div>

    <!-- 重新开始按钮 -->
    <div class="game-controls">
      <button
        v-if="gameOver || gameWon || userGaveUp"
        @click="handleReset"
        class="reset-button"
      >
        重新开始
      </button>
    </div>
  </div>
</template>

<script>
import { ref, watch, onMounted, nextTick, computed } from 'vue';
import { getOperatorAvatarFile, getImagePath } from '../utils/imageUtils';
import {
  loadPuzzleImage,
  initBlocks,
  refineRandomBlocks,
  renderMosaic
} from '../logic/puzzleService';

export default {
  name: 'PuzzleBoard',
  props: {
    operators: {
      type: Array,
      required: true
    },
    targetOperator: {
      type: Object,
      required: true
    },
    maxGuesses: {
      type: Number,
      required: true
    },
    gameOver: {
      type: Boolean,
      required: true
    },
    gameWon: {
      type: Boolean,
      required: true
    },
    userGaveUp: {
      type: Boolean,
      default: false
    },
    guesses: {
      type: Array,
      required: true
    },
    initialGridSize: {
      type: Object,
      default: () => ({ rows: 4, cols: 4 })
    },
    refinementCount: {
      type: Number,
      default: 9
    },
    refinementFactor: {
      type: Object,
      default: () => ({ rows: 2, cols: 2 })
    }
  },
  emits: ['reset'],
  setup(props, { emit }) {
    const loadingImage = ref(true);
    const puzzleImageUrl = ref('');
    const scaledWidth = ref(0);
    const scaledHeight = ref(0);
    const integralData = ref(null);
    const blocks = ref([]);
    const areaRefinementLevels = ref({});
    const mosaicCanvas = ref(null);
    const initialViewportWidth = ref(window.innerWidth);

    // （A）提示间隔，可根据需要自行修改
    const puzzleHintInterval = 3;

    // （B）提示列表，可根据需要自行修改
    // 每一个对象里可以是 { label, value }，value可以是字符串或函数
    const puzzleHints = ref([
      {
        label: '星级',
        value: () => props.targetOperator?.星级 || '?'
      },
      {
        label: '职业',
        value: () => props.targetOperator?.职业 || '?'
      },
      {
        label: '阵营/种族',
        value: () => props.targetOperator?.种族 || '?'
      },
      {
        label: '国籍',
        value: () => props.targetOperator?.国家 || '?'
      }
      // ... 如果需要更多提示，可继续往下添加
    ]);

    // （C）根据已经失败（错误）次数，计算该显示到第几条提示
    const hintIndex = computed(() => {
      if (props.gameWon || props.gameOver || props.userGaveUp) {
        return 0; // 游戏结束后不再增显提示
      }
      // count how many incorrect guesses so far
      const incorrectCount = props.guesses.filter(g => g.干员 !== props.targetOperator.干员).length;
      // 每 puzzleHintInterval 次错误猜测解锁一条提示
      const idx = Math.floor(incorrectCount / puzzleHintInterval);
      // 不可超过 puzzleHints 数量
      return Math.min(idx, puzzleHints.value.length);
    });

    // 实际要显示的提示
    const displayedHints = computed(() => {
      return puzzleHints.value.slice(0, hintIndex.value);
    });

    function getOperatorAvatar(op) {
      const file = getOperatorAvatarFile(op.干员, op.稀有度);
      return getImagePath(file);
    }

    // 初始化Puzzle
    watch(
      () => props.targetOperator,
      async (newVal) => {
        if (newVal) {
          await initPuzzle();
        }
      },
      { immediate: true }
    );

    // 每次新增一次猜测且游戏还在继续时，做一次细化
    watch(
      () => props.guesses.length,
      async (newLen, oldLen) => {
        if (newLen > oldLen) {
          // 如果游戏已经结束或猜对，则不细化了
          if (props.gameOver || props.gameWon || props.userGaveUp) return;
          const lastGuess = props.guesses[newLen - 1];
          // 只有当猜错时，才做细化
          if (lastGuess.干员 !== props.targetOperator.干员) {
            await refineAndRender();
          }
        }
      }
    );

    // 如果在猜的过程中直接 gameOver 或 guessCorrect，需要触发一次渲染
    watch(
      () => [props.gameOver, props.gameWon, props.userGaveUp],
      async ([over, won, gaveUp], [oldOver, oldWon, oldGaveUp]) => {
        // 只要状态变化，就刷新一下
        if (!loadingImage.value) {
          await nextTick();
          renderMosaicIfNeeded();
        }
      }
    );

    async function initPuzzle() {
      if (!props.targetOperator) return;
      loadingImage.value = true;
      try {
        const result = await loadPuzzleImage(
          props.targetOperator,
          600,
          600,
          initialViewportWidth.value
        );
        puzzleImageUrl.value = result.puzzleImageUrl;
        scaledWidth.value = result.scaledWidth;
        scaledHeight.value = result.scaledHeight;
        integralData.value = result.integralData;

        blocks.value = initBlocks(
          scaledWidth.value,
          scaledHeight.value,
          props.initialGridSize,
          integralData.value,
          0.01
        );

        areaRefinementLevels.value = {};
        for (let r = 0; r < props.initialGridSize.rows; r++) {
          for (let c = 0; c < props.initialGridSize.cols; c++) {
            areaRefinementLevels.value[`${r},${c}`] = 0;
          }
        }

        loadingImage.value = false;
        await nextTick();

        // 初次渲染马赛克
        if (!props.gameOver && !props.gameWon && !props.userGaveUp) {
          renderMosaicIfNeeded();
        } else if (props.gameWon) {
          // 如果开局就满足 gameWon（极少情况），也给它渲染一下
          renderMosaicIfNeeded();
        }
      } catch (err) {
        console.error('初始化 Puzzle 出错:', err);
        loadingImage.value = false;
      }
    }

    function renderMosaicIfNeeded() {
      const canvas = mosaicCanvas.value;
      if (!canvas || !integralData.value) return;
      const ctx = canvas.getContext('2d');
      renderMosaic(ctx, blocks.value, integralData.value, scaledWidth.value, scaledHeight.value);
    }

    async function refineAndRender() {
      refineRandomBlocks(
        blocks.value,
        areaRefinementLevels.value,
        props.refinementCount,
        props.refinementFactor,
        props.initialGridSize,
        integralData.value,
        scaledWidth.value,
        scaledHeight.value,
        0.01
      );
      await nextTick();
      renderMosaicIfNeeded();
    }

    function handleReset() {
      emit('reset');
    }

    onMounted(() => {
      // no-op
    });

    return {
      loadingImage,
      puzzleImageUrl,
      scaledWidth,
      scaledHeight,
      mosaicCanvas,
      getOperatorAvatar,
      handleReset,
      displayedHints
    };
  }
};
</script>

<style>
.puzzle-board {
  margin-top: 20px;
  width: 100%;
  box-sizing: border-box;
  padding: 0;
  color: var(--color-text);
}

.game-status {
  text-align: center;
  margin-bottom: 10px;
  width: 100%;
}

.status-message {
  padding: 12px;
  border-radius: 6px;
  font-weight: bold;
  font-size: 18px;
  word-wrap: break-word;
  white-space: normal;
  max-width: 600px;
  margin: 0 auto;
}
.win {
  background-color: var(--color-win-bg);
  color: var(--color-win-text);
}
.lose {
  background-color: var(--color-lose-bg);
  color: var(--color-lose-text);
}
.attempts-counter {
  font-size: 18px;
  color: var(--color-text);
  font-weight: 500;
}

/* 提示信息 */
.puzzle-hints {
  background-color: rgba(255, 255, 255, 0.08);
  padding: 10px 14px;
  border-radius: 6px;
  margin-bottom: 10px;
  text-align: left;
  max-width: 600px;
  margin-left: auto;
  margin-right: auto;
}
.puzzle-hints h3 {
  margin: 0 0 8px 0;
  font-weight: 600;
  font-size: 15px;
}
.puzzle-hints ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
.puzzle-hints li {
  margin-bottom: 4px;
  font-size: 14px;
}

/* 图片正在加载 */
.image-loading-indicator {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 200px;
  background-color: rgba(255,255,255,0.05);
  border-radius: 4px;
  margin: 10px 0;
  font-size: 16px;
  color: #666;
}

/* 马赛克容器 */
.mosaic-container {
  position: relative;
  margin: 0 auto;
  border: 1px solid var(--color-border);
  border-radius: 4px;
  background-color: #f5f5f5;
  overflow: hidden;
}

/* 猜对后，左右对比容器 */
.final-compare-container {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  justify-content: center;
  align-items: flex-start;
  margin-top: 20px;
}
.final-compare-left,
.final-compare-right {
  flex: 0 0 auto;
  text-align: center;
}

/* 统一的图片样式 */
.final-image-container {
  text-align: center;
  margin-top: 20px;
  width: 100%;
}
.final-image {
  border: 1px solid var(--color-border);
  border-radius: 6px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  max-width: 100%;
  height: auto;
}

/* 猜过的干员列表 */
.guesses-container {
  margin-top: 16px;
  width: 100%;
}
.guesses-container h4 {
  margin-bottom: 10px;
}
.guess-list {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-top: 8px;
}
.guess-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 8px;
  border-radius: 8px;
  transition: background-color 0.2s;
}
.correct {
  background-color: rgba(76, 175, 80, 0.15);
}
/* .incorrect {
  background-color: rgba(189, 189, 189, 0.15);
} */
.guess-avatar {
  width: 50px;
  height: 50px;
  object-fit: cover;
  border-radius: 50%;
  background-color: #eee;
}
.guess-name {
  margin-top: 4px;
  font-size: 12px;
  color: var(--color-text);
}

/* 控制按钮 */
.game-controls {
  margin-top: 20px;
  display: flex;
  justify-content: center;
}
.reset-button {
  padding: 10px 24px;
  font-size: 16px;
  font-weight: 500;
  background-color: var(--color-primary);
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color var(--transition-duration);
}
.reset-button:hover {
  background-color: var(--color-primary-hover);
}

@media (max-width: 768px) {
  .puzzle-hints {
    font-size: 14px;
    padding: 8px;
  }
  .final-compare-container {
    flex-direction: column;
    align-items: center;
  }
  .guess-list {
    justify-content: center;
  }
  .guess-item {
    width: 70px;
  }
}
</style>

=== FILE END: ./src/components/PuzzleBoard.vue ===

=== FILE START: ./src/components/TagSelector.vue ===
<template>
  <div class="tag-selector">
    <h3 class="selector-title">选择你的头</h3>

    <div class="tag-groups">
      <div
        v-for="group in tagGroups"
        :key="group.id"
        class="tag-group-item"
        :class="{ active: selectedGroup.id === group.id }"
        @click="selectGroup(group.id)"
      >
        <div class="group-header">
          <span class="group-name">{{ group.name }}</span>
          <span v-if="selectedGroup.id === group.id" class="selected-indicator">✓</span>
        </div>
        <p class="group-description">{{ group.description }}</p>
        <div class="group-tags">
          <span v-for="tag in group.tags" :key="tag" class="tag-badge">
            {{ tag }}
          </span>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: 'TagSelector',
  props: {
    tagGroups: {
      type: Array,
      required: true
    },
    selectedGroup: {
      type: Object,
      required: true
    }
  },
  emits: ['select'],
  setup(props, { emit }) {
    const selectGroup = (groupId) => {
      emit('select', groupId);
    };
    return {
      selectGroup
    };
  }
};
</script>

<style>
.tag-selector {
  background-color: var(--color-card-bg);
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
  padding: 16px;
  margin-bottom: 20px;
  color: var(--color-text);
  transition: background-color var(--transition-duration);
}

.selector-title {
  margin: 0 0 16px 0;
  font-size: 18px;
  font-weight: 500;
  text-align: center;
}

.tag-groups {
  display: flex;
  gap: 16px;
  overflow-x: auto;
  padding-bottom: 8px;
  justify-content: center;
}

.tag-groups::-webkit-scrollbar {
  height: 6px;
}
.tag-groups::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 3px;
}
.tag-groups::-webkit-scrollbar-thumb {
  background: #ccc;
  border-radius: 3px;
}
.tag-groups::-webkit-scrollbar-thumb:hover {
  background: #aaa;
}

.tag-group-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  flex: 0 0 auto;
  min-width: 160px;
  max-width: 250px;
  padding: 14px;
  border-radius: 6px;
  border: 2px solid var(--color-border);
  cursor: pointer;
  transition: all var(--transition-duration);
}
.tag-group-item:hover {
  border-color: var(--color-primary);
  background-color: rgba(255, 255, 255, 0.07);
}
.tag-group-item.active {
  border-color: var(--color-primary);
  background-color: rgba(52, 152, 219, 0.12);
}

.group-header {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
  margin-bottom: 8px;
}
.group-name {
  font-weight: 600;
  font-size: 16px;
}
.selected-indicator {
  margin-left: 8px;
  color: var(--color-primary);
  font-weight: bold;
  font-size: 18px;
}

.group-description {
  font-size: 13px;
  color: #666;
  margin-bottom: 12px;
  line-height: 1.4;
}

.group-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  justify-content: center;
}

.tag-badge {
  background-color: #eef2f7;
  padding: 3px 8px;
  border-radius: 4px;
  font-size: 12px;
  color: #555;
}

@media (max-width: 768px) {
  .selector-title {
    font-size: 16px;
    margin-bottom: 12px;
  }
  .tag-group-item {
    min-width: 100px;
    max-width: 150px;
    padding: 8px;
  }
  .group-name {
    font-size: 14px;
  }
  .group-description {
    display: none;
  }
  .group-tags {
    display: none;
  }
}
</style>

=== FILE END: ./src/components/TagSelector.vue ===

